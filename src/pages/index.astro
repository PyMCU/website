---
// Keep this page static in hybrid mode
export const prerender = false;

import Layout from '~/layouts/PageLayout.astro';

import Hero from '~/components/widgets/Hero.astro';
import Note from '~/components/widgets/Note.astro';
import Features from '~/components/widgets/Features.astro';
import Steps from '~/components/widgets/Steps.astro';
import Content from '~/components/widgets/Content.astro';
import FAQs from '~/components/widgets/FAQs.astro';
import RoadmapArchitectures from '../components/widgets/RoadmapArchitectures.astro';
import Countdown from '../components/widgets/Countdown.astro';
import Waitlist from '../components/widgets/Waitlist.astro';

const metadata = {
  title: 'PyMCU — Python to MCUs. Free. Deterministic. AOT.',
  ignoreTitleTemplate: true,
};
---

<Layout metadata={metadata}>
  <!-- Hero Widget ******************* -->

  <Hero
    actions={[
      {
        variant: 'primary',
        text: 'Join the Waitlist',
        href: '#waitlist',
      },
    ]}
    image={{ src: '~/assets/images/pymcu-logo.png', alt: 'PyMCU Logo' }}
  >
    <Fragment slot="title">
      <span class="text dark:text-accent">Py</span><span class="text-accent dark:text-white">MCU</span>
    </Fragment>

    <Fragment slot="subtitle">
      <span class="hidden sm:inline">
        <span class="font-semibold">PyMCU</span> is a free, deterministic compiler that brings
        <span class="font-semibold">Python</span> to microcontrollers. It turns a safe subset of Python into <span
          class="font-semibold">ASM</span
        > or <span class="font-semibold">C</span>
        without OS or garbage collection, with planned toolchain support. Ideal for prototyping, education, makers, and future
        8-bit & 32-bit architectures.
      </span>
    </Fragment>
  </Hero>

  <!-- Note Widget ******************* -->

  <Note title="Philosophy:" description="Determinism, No OS and High Performance" />

  <!-- Features Widget *************** -->

  <Features
    id="features"
    tagline="Features"
    title="What you will get with PyMCU"
    subtitle="A free, deterministic compiler designed to bring the simplicity of Python to microcontrollers. A new way to write embedded software that is predictable, efficient and accessible."
    items={[
      {
        title: 'Python to Low-Level Compilation',
        description:
          'A seamless way to bring Python into embedded systems, compiling a safe subset into ASM or C for predictable and efficient execution.',
        icon: 'tabler:terminal-2',
      },
      {
        title: 'Ready-to-use HALs',
        description:
          'Hardware Abstraction Layers that make GPIO, timers and peripherals easy to use, accelerating development for makers, students and professionals.',
        icon: 'tabler:plug-connected',
      },
      {
        title: 'Best Practices',
        description:
          'Building firmware that is deterministic, efficient and production-ready, with predictable timing and no garbage collection.',
        icon: 'tabler:shield-check',
      },
      {
        title: 'Excellent Performance',
        description:
          'Ahead-Of-Time compilation ensures binaries run close to the hardware, making the most of limited 8-bit and 32-bit resources.',
        icon: 'tabler:gauge',
      },
      {
        title: 'Ecosystem & Future Support',
        description:
          'Planned compatibility with standard toolchains and architectures, opening the door to broader adoption and long-term growth.',
        icon: 'tabler:layers-linked',
      },
      {
        title: 'Open to new ideas and contributions',
        description:
          'PyMCU is community-driven, open to feedback and contributions that foster innovation, collaboration and a growing ecosystem.',
        icon: 'tabler:bulb',
      },
    ]}
  />

  <!-- Content Widget **************** -->

  <Content
    id="inside-pymcu"
    isReversed
    tagline="Inside PyMCU"
    title="PyMCU's Blueprint: Python Meets Bare Metal!"
    items={[
      {
        title: 'Built on top of a safe Python subset',
        description: 'Benefit from a language millions already know, adapted for deterministic, embedded use.',
      },
      {
        title: 'Simplified learning curve',
        description:
          'Facilitating faster onboarding for students, makers, and professionals by lowering the entry barrier to firmware development.',
      },
      {
        title: 'Cross-toolchain compatibility',
        description:
          'Ensuring your Python-to-ASM/C workflow can integrate smoothly with existing toolchains and future 8-bit & 32-bit architectures.',
      },
    ]}
    image={{
      src: '~/assets/images/embedded-engineer.png',
      alt: 'Embedded Engineer',
    }}
  >
    <Fragment slot="content">
      <h3 class="text-2xl font-bold tracking-tight dark:text-white sm:text-3xl mb-2">
        Building on deterministic foundations
      </h3>
      Gain an advantage by leveraging the simplicity and readability of Python as your starting point.
    </Fragment>

    <Fragment slot="bg">
      <div class="absolute inset-0 bg-blue-50 dark:bg-transparent"></div>
    </Fragment>
  </Content>

  <!-- Content Widget **************** -->

  <Content
    isAfterContent
    items={[
      {
        title: 'Make your first firmware fast and simple',
        description: `Start coding right away with ready-to-use project presets that include minimal HALs for GPIO and timers.`,
      },
      {
        title: 'Direct to low-level',
        description:
          'Transform Python directly into ASM or C, producing binaries that run close to the hardware without extra layers.',
      },
      {
        title: 'Reliable timing',
        description: 'Enjoy predictable execution with no garbage collection or operating system interruptions.',
      },
      {
        title: 'Built to expand',
        description:
          'The alpha focuses on small 8-bit targets, with a roadmap toward richer peripherals, more architectures, and broader toolchain support.',
      },
    ]}
    image={{
      src: '~/assets/images/embedded-python.png',
      alt: 'Embedded Python',
    }}
  >
    <Fragment slot="content">Ensure your firmware truly represents your code.</Fragment>

    <Fragment slot="bg">
      <div class="absolute inset-0 bg-blue-50 dark:bg-transparent"></div>
    </Fragment>
  </Content>

  <!-- Content Widget **************** -->

  <Content
    isReversed
    isAfterContent
    items={[
      {
        title: 'Early prototyping',
        description:
          'Quickly bring ideas to life with minimal configuration, turning concepts into working firmware in record time.',
      },
      {
        title: 'Ongoing evolution',
        description:
          'Stay aligned with the roadmap as PyMCU grows to support more architectures, peripherals, and workflows.',
      },
      {
        title: 'Efficiency for developers',
        description:
          'Skip complex toolchain setups and focus on coding, reducing the time and effort needed to test firmware on real hardware.',
      },
      {
        title: 'Community-driven',
        description: `Be part of the PyMCU community—sharing knowledge, building resources, and shaping the future of Python in embedded systems together.`,
      },
    ]}
    image={{
      src: '~/assets/images/collaboration-pymcu.png',
      alt: 'Astronauts Image',
    }}
  >
    <Fragment slot="content">Designed to empower embedded innovation.</Fragment>

    <Fragment slot="bg">
      <div class="absolute inset-0 bg-blue-50 dark:bg-transparent"></div>
    </Fragment>
  </Content>

  <!-- Steps Widget ****************** -->

  <Steps
    id="steps"
    title="Get your first firmware running in no time with PyMCU."
    items={[
      {
        title: 'Step 1: <span class="font-medium">Install</span>',
        description:
          'Kickstart with GitHub! Clone the PyMCU repository or grab the prebuilt package. Future releases will also be available through package managers like Homebrew or Chocolatey, making setup even easier.',
        icon: 'tabler:package',
      },
      {
        title: 'Step 2: <span class="font-medium">Write code</span>',
        description:
          'Bring your ideas to life. Write in a safe subset of Python, which is simple, familiar, and clean. Your code turns directly into ASM or C, ready for real hardware.',
        icon: 'tabler:brand-python',
      },
      {
        title: 'Step 3: <span class="font-medium">Flash & test</span>',
        description:
          'Load the generated binary into your microcontroller and watch it run with deterministic timing. Fast iterations, predictable results.',
        icon: 'tabler:usb',
      },
      {
        title: 'Ready!',
        icon: 'tabler:check',
      },
    ]}
    image={{
      src: 'https://images.unsplash.com/photo-1616198814651-e71f960c3180?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=987&q=80',
      alt: 'Steps image',
    }}
  />

  <!-- Roadmap Widget ******* -->

  <RoadmapArchitectures
    id="roadmap"
    tagline="Roadmap"
    title="Architecture Support Timeline"
    subtitle="Our planned microcontroller support roadmap"
    columns={2}
  >
    <Fragment slot="bg">
      <div class="absolute inset-0 bg-blue-50 dark:bg-transparent"></div>
    </Fragment>
  </RoadmapArchitectures>

  <!-- HighlightedPosts Widget ******* -->

  <!--
  <BlogLatestPosts
    title="Find out more content in our Blog"
    information={`The blog is used to display AstroWind documentation.
                        Each new article will be an important step that you will need to know to be an expert in creating a website using Astro + Tailwind CSS.
                        Astro is a very interesting technology. Thanks.
                `}
  />
  -->

  <!-- FAQs Widget ******************* -->

  <FAQs
    id="faqs"
    title="Frequently Asked Questions"
    subtitle="Dive into the following questions to gain insights into what PyMCU is, where it’s going, and how it can reshape embedded development with Python."
    tagline="FAQs"
    classes={{ container: 'max-w-6xl' }}
    items={[
      {
        title: 'What is PyMCU?',
        description:
          'PyMCU is an experimental compiler that translates a safe subset of Python into ASM or C for microcontrollers. It is designed to be deterministic, lightweight, and Ahead-Of-Time (AOT), bringing the simplicity of Python into the world of bare-metal development.',
      },
      {
        title: 'Is PyMCU production-ready?',
        description:
          'Not yet. PyMCU is currently in an early, experimental stage. Its progress will depend on community interest, contributions, and feedback. While there is no guarantee of a full release, every step forward is aimed at building something valuable and open for embedded developers.',
      },
      {
        title: 'How is PyMCU being built?',
        description:
          'The compiler is written in C++, using a Parsing Expression Grammar (PEG) to have fine-grained control over the Python subset. This allows PyMCU to stay minimal, predictable, and tailored for embedded systems.',
      },
      {
        title: 'What license will PyMCU use?',
        description:
          'PyMCU will be released under the MIT License — simple, permissive, and open. This ensures anyone can use, adapt, or contribute to the project with full transparency.',
      },
      {
        title: 'Will it support official toolchains?',
        description:
          'Yes, the long-term plan is to align with official toolchains provided by each vendor (such as those for PIC, AVR, ARM Cortex-M, and ESP32). This will let developers combine PyMCU with trusted ecosystems they already know.',
      },
      {
        title: 'Which architectures are on the roadmap?',
        description:
          'The roadmap — outlined in its own dedicated section — begins with PIC10F/12F (ASM) in late Q4 2025, followed by AVR8/ATmega (C with ASM option) in early Q1 2026, ARM Cortex-M (C with ASM option) in mid Q2 2026, and ESP32 (C with ASM option and Wi-Fi stubs) in late Q3 2026. Future architectures will be evaluated and prioritized based on community input.',
      },
      {
        title: 'How does it differ from MicroPython or CircuitPython?',
        description:
          'PyMCU is not an interpreter. It doesn’t run a VM or rely on dynamic memory. Instead, it compiles directly to low-level code, with deterministic timing and no garbage collection. It is designed for developers who need Python’s clarity but firmware’s reliability.',
      },
      {
        title: 'How can I get involved?',
        description:
          'You will soon be able to take part in shaping PyMCU from the ground up — by following the project on GitHub, sharing feedback on features and roadmap priorities, and contributing code, documentation, or testing. Once these channels are available, every contribution will help strengthen and grow the ecosystem.',
      },
    ]}
  />

  <!-- Countdown Widget ****************** -->

  <Countdown
    title="Alpha 1"
    subtitle="Join us on this exciting journey to bring Python to microcontrollers."
    tagline="Coming soon"
    targetDate="2025-12-15T00:00:00"
  />

  <!-- CallToAction Widget *********** -->

  <Waitlist id="waitlist" title="Join the Alpha" subtitle="Be the first to experience PyMCU" tagline="Early Access" />
</Layout>
